"""
Face Recognition Middleware using Supabase (with pgvector) and dotenv for configuration.

Setup:
  1. Create a `.env` file in your project root with:
     ```ini
     SUPABASE_URL=https://<your-project>.supabase.co
     SUPABASE_KEY=<your-service-role-or-anon-key>
     MATCH_THRESHOLD=0.6  # optional, defaults to 0.6
     SOCKET_PATH=/tmp/face_middleware.sock  # optional, defaults shown
     ```

  2. Enable the pgvector extension in your database:
     ```sql
     -- in the SQL editor or psql:
     CREATE EXTENSION IF NOT EXISTS vector;
     ```

  3. Create the `profiles` table:
     ```sql
     CREATE TABLE IF NOT EXISTS profiles (
       id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       name       TEXT,
       embedding  VECTOR(512),
       first_seen TIMESTAMPTZ,
       last_seen  TIMESTAMPTZ
     );
     ```

  4. Create the `match_face` RPC function to find the nearest neighbor under threshold:
     ```sql
     CREATE OR REPLACE FUNCTION match_face(
       embedding vector(512),
       threshold float
     ) RETURNS TABLE (
       id BIGINT,
       name TEXT,
       distance float
     ) AS $$
     BEGIN
       RETURN QUERY
       SELECT id, name, embedding <-> embedding_arg AS distance
       FROM profiles
       WHERE (embedding <-> embedding_arg) < threshold
       ORDER BY distance ASC
       LIMIT 1;
     END;
     $$ LANGUAGE plpgsql;
     ```

  5. Install dependencies:
     ```bash
     uv add face-recognition supabase python-dotenv
     pip install git+https://github.com/ageitgey/face_recognition_models
     ```

Usage:
  ```bash
  uv run -m middlewares.face_recognition_middleware
  ```
  RPC method: `process` on the socket (default `/tmp/face_middleware.sock`)
"""
import os
import socket
import threading
import json
import logging
from datetime import datetime

# load .env variables
def load_env():
    from dotenv import load_dotenv
    load_dotenv()
load_env()

import face_recognition
from supabase import create_client, Client
from sensors.vision.client import VisionClient

# Configure logging
default_format = '%(asctime)s %(levelname)s %(message)s'
logging.basicConfig(format=default_format, level=logging.INFO)
logger = logging.getLogger('FaceMiddleware')

# read configuration from environment
DEFAULT_SOCKET = os.getenv('SOCKET_PATH', '/tmp/face_middleware.sock')
MATCH_THRESHOLD = float(os.getenv('MATCH_THRESHOLD', 0.6))

class FaceRecognitionMiddleware:
    """
    Middleware that reads frames from the Vision service, detects faces,
    matches or inserts profiles in Supabase (pgvector), and exposes a JSON-RPC API
    over a Unix socket to retrieve detections as JSON.

    Configuration is read from environment via python-dotenv.
    """
    def __init__(
        self,
        supabase_url: str = None,
        supabase_key: str = None,
        socket_path: str = None,
        match_threshold: float = None
    ):
        # Load credentials and threshold
        url = supabase_url or os.getenv('SUPABASE_URL')
        key = supabase_key or os.getenv('SUPABASE_KEY')
        self.match_threshold = match_threshold or MATCH_THRESHOLD

        # Initialize Supabase client
        self.supabase: Client = create_client(url, key)
        logger.info('Supabase client initialized')

        # Vision client for reading camera frames
        self.vision = VisionClient()
        logger.info('VisionClient connected')

        # Setup Unix socket path
        self.socket_path = socket_path or DEFAULT_SOCKET
        try:
            os.unlink(self.socket_path)
        except OSError:
            pass
        self.server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        self.server.bind(self.socket_path)
        os.chmod(self.socket_path, 0o660)
        self.server.listen()
        threading.Thread(target=self._serve, daemon=True).start()
        logger.info(f'Listening on {self.socket_path} for JSON-RPC')

    def _serve(self):
        logger.info('RPC server thread started')
        while True:
            conn, _ = self.server.accept()
            logger.debug('Accepted new connection')
            threading.Thread(target=self._handle, args=(conn,), daemon=True).start()

    def _handle(self, conn):
        data = conn.recv(4096).decode('utf-8')
        logger.debug(f'Received request: {data}')
        try:
            req = json.loads(data)
            method = req.get('method')
            rid = req.get('id')

            if method == 'process':
                logger.info('Processing frame')
                result = self.process_frame()
                resp = {'jsonrpc': '2.0', 'result': result, 'id': rid}
            else:
                resp = {
                    'jsonrpc': '2.0',
                    'error': {'code': -32601, 'message': 'Method not found'},
                    'id': rid
                }
                logger.warning(f'Unknown method: {method}')
        except Exception as e:
            logger.exception('Error during request handling')
            resp = {'jsonrpc': '2.0', 'error': {'code': -32000, 'message': str(e)}, 'id': None}

        # Send response, guarding against broken pipe
        try:
            conn.send(json.dumps(resp).encode('utf-8'))
            logger.debug('Response sent')
        except BrokenPipeError:
            logger.warning('Client disconnected before response could be sent')
        finally:
            conn.close()
            logger.debug('Connection closed')

    def process_frame(self) -> dict:
        frame_id, frame = self.vision.read()
        logger.info(f'Read frame {frame_id}')
        rgb = frame[:, :, ::-1]

        # Detect faces and compute embeddings
        locations = face_recognition.face_locations(rgb)
        encodings = face_recognition.face_encodings(rgb, locations)
        logger.info(f'Detected {len(locations)} face(s)')

        profiles = []
        now = datetime.utcnow().isoformat()
        for bbox, enc in zip(locations, encodings):
            rpc_res = self.supabase.rpc('match_face', {
                'embedding': enc.tolist(),
                'threshold': self.match_threshold
            }).execute()
            match = rpc_res.data[0] if rpc_res.data else None

            if match:
                self.supabase.table('profiles')\
                    .update({'last_seen': now})\
                    .eq('id', match['id'])\
                    .execute()
                logger.debug(f'Matched profile {match["id"]} distance={match.get("distance")}')
                profiles.append({
                    'profile_id': match['id'],
                    'name': match['name'],
                    'distance': match.get('distance'),
                    'bbox': bbox,
                    'last_seen': now
                })
            else:
                ins = {'name': 'unknown', 'embedding': enc.tolist(), 'first_seen': now, 'last_seen': now}
                insert_res = self.supabase.table('profiles').insert(ins).execute()
                new_id = insert_res.data[0]['id']
                logger.info(f'Inserted new profile {new_id}')
                profiles.append({
                    'profile_id': new_id,
                    'name': 'unknown',
                    'distance': None,
                    'bbox': bbox,
                    'last_seen': now
                })

        return {'frame_id': frame_id, 'timestamp': now, 'profiles': profiles}

if __name__ == '__main__':
    import time
    svc = FaceRecognitionMiddleware()
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logger.info('Shutting down FaceRecognitionMiddleware...')
